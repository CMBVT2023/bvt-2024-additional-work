<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Tutorial Code Along: Ten Steps to Mastering the Fetch API</title>
</head>
<body>

    <div id="main-container">
        <img src="./assets/pexels-photo-1525041.jpeg" id="pic">

        <h1><a href="https://www.youtube.com/watch?v=2sQ9xiEAXNo&ab_channel=SteveGriffith-Prof3ssorSt3v3">Ten Steps to Mastering the Fetch API</a></h1>
        <h2 id="example-header"></h2>
        <ul id="example-list">
            <!-- <li data-uid="">
                <p>First Name: </p>
                <p>Last Name: </p>
            </li> -->
        </ul>

        <h2>Left off at 1:24:34 on part 7.</h2>

        <ol>
            <li>Basic Fetch Requests</li>
            <li>Async and Await</li>
            <li>URL Request</li>
            <li>Responses</li>
            <li>Generate</li>
            <li>Authentication</li>
            <li>Uploading Data</li>
            <li>Cross Origin Resource Sharing (CORS)</li>
            <li>Dealing with Multiple Fetch Calls</li>
            <li>Aborting Fetch Calls</li>
            <li>Bonus: Measuring Download Progress of a Fetch</li>
        </ol>

        <div id="part-1" class="notes">
            <h3>Part 1 - Additional Notes:</h3>
            <ul>
                <li>
                    HTTP Status Codes:
                    <ul>
                        <li>100: intermediate status</li>
                        <li>200: everything worked</li>
                        <li>300: a redirect occurred</li>
                        <li>400: the request was not authorized or authentication failed</li>
                        <li>404: request did not point to a valid URL</li>
                        <li>500: server side errors</li>
                    </ul>
                </li>
                <li>
                    If you are chaining then handlers for a promise, the previous then handler must return a promise via a return argument in order for the next then handler to delay its code's execution. <br>
                    Otherwise there is no delay between both .then handlers.
                    Example: <br>
                    fetch(url)<br>
                    .then("This then handler would need to return a promise in order for the next then handler to execute only when this one is finished or when the promise is returned.")<br>
                    .then("If the previous then handler never returns a promise, then this code is executed right after the previous then handler without a delay.")
                </li>
            </ul>
            <h3>Takeaway</h3>
            <p>
                This mainly shows why fetch and promises are necessary when getting data from an outside source. There is no way to know how long it will take for a client to access data from a separate 
                server or for a fetch request to access a file from another site. Using a promise allows the webpage's main code to continue executing without having to wait for each fetch request to 
                complete before moving on with the code execution. Also, this example shows the importance of error handling and that no matter watch, a catch handler should always be present when using then handlers
                to help troubleshoot and to log errors that might occur, which is important especially when accessing outside resources, servers, or other clients since problems other than code gets introduced.
            </p> 
        </div>

        <div id="part-2" class="notes">
            <h3>Part 2 - Additional Notes:</h3>
            <ul>
                <li>
                    Async and Await allow the same functionality as .then when using fetch <br>
                    While it does the same thing it actually pauses code execution when a fetch statement is reached, and only when it
                    the fetch is completed will it then assign the results to a variable or continue with executing code.
                </li>
                <li>
                    One down side to this method is that you still need to implement some kind of error handling in the form or a try and catch statement.
                </li>
               
            <h3>Takeaway</h3>
            <p>
                This mainly showed a different way to write asynchronous fetch statement. While the .then chaining method works, this is just an alternate <br>
                way to handle fetch statements. Still, even though the base code is easier to write, you still need to take into account errors that can occur by <br>
                implementing try and catch statements and you have to remember to implement any these fetch statements in a specific async function, otherwise the await <br>
                key word will not be useable.
            </p> 
        </div>

        <div id="part-3" class="notes">
            <h3>Part 3 - Additional Notes:</h3>
            <ul>
                <li>
                    URL is a new object constructor that allows you to create a url based on a string, in the example it will generate a url and point it towards the
                    assets folder and then to the local-sample.json, the host part of the url uses the local server ip address, which is your computer's loopback address and the port is
                    the default port that live server uses. 
                </li>
                <li>
                    Request is another new object constructor that is introduced and it allows you to access a url and do so specifically, it is used in tandem with fetch.The additional options of how you want the data to be
                    accessed and handled by the browser allows for more control and better handling of the data being pulled from the request, such as caching or only requesting to get data from the server and not send any to it.
                </li>
                <li>
                    <h3>All Cache options when the http cache method.</h3>
                    <ul>
                        <li>`default`: cache first, server request if stale, update cache if newer</li>
                        <li>`reload`: always go to server AND update the cache</li>
                        <li>`no-store`: always go to server but do not update the cache</li>
                        <li>`no-cache`: make a conditional request to server and compare, update cache and use latest</li>
                        <li>`force-cache`: only makes request if there is no HTTP Cache file</li>
                        <li>`only-if-cache`: from cache or 504 gateway timeout error</li>
                    </ul>
                </li>
                <li>
                    When creating a request, an object can be passed in as the second parameter that specifies the various options such as the method to use, the cache type, and headers that the user can create.
                </li>
               
            <h3>Takeaway</h3>
            <p>
                There are two new object constructors introduced in this example, the request and url object. Up until this point, the way that the fetch requests have access webpages is via entering the url through a string,
                but by passing that string through a url constructor first, it provides more options when accessing the url, such as pulling the origin, host, and port, which could be helpful for later use. The request constructor
                provides even more options in the form of how the browser will handle the request to the url, such as if any info is saved to the webpage's cache on the user's computer or if information is only pulled from the webpage 
                instead of sending any info too.
            </p> 
        </div>

        <div id="part-4" class="notes">
            <h3>Part 4 - Additional Notes:</h3>
            <ul>
                <li>
                    A response object is a container that has a file inside of it, the main body of the response object is the file.
                </li>
                <li>
                    HTTP Request and HTTP Responses have two parts, a head and a body, the header has the various options and the settings of the response or Request
                    the body is the actual information or the file information, it can be empty or can have something that was pulled or pushed to the webpage.
                </li>
                <li>
                    There are three properties inside of the settings or properties for the response's object parameter, the status code to signify the status, if its good or bad, statusText to describe the status, and headers, which can be custom but they have to start with the 
                    letter x if it is custom, and there are some you can change and other you cannot alter, the browser can only do so.
                </li>
                <li>
                    For the headers that you are allowed to access from responses, like is this example the content-type and content-length, you use the .get(headerName) on the header property.
                    Example, to get the size of the response object you would type response.headers.get('content-length'). Response is the variable name for the response created from the request constructor,
                    headers if the property name that stores that headers object. and .get is the method used to retrieve the value of the passed in header name.
                </li>
                <li>
                    .blob() is used in place of .json() if you are fetching an image or video as it stands for binary large object. Attempting to log a blob() result will just specify the object type and size.
                    It can displayed on the html page by inserting the blob creating a url via pointing the url to the place that the blob is stored in memory using createObjectURL() method on the URL constructor object.
                    Example, URL.createObjectURL(blob) will create a url that points to where a variable that stores the blob data from a fetch request is in the webpage's memory.
                </li>
            <h3>Takeaway</h3>
            <p>
                The response object constructor can be used in tandem with the request object to provide further details to the web browser about the information that a fetch request pulls. Rather than just pulling an object without having knowledge of its file type or size, response and request can provide details about the file they contain within their body via properties accessible through their head.
                Also, this tutorial showed the difference and use cases for a blob instead of json when pulling data, basically any time you are pulling an image, video, or audio file, blob is used and not json. Json should only be for text.
            </p> 
        </div>

        <div id="part-5" class="notes">
            <h3>Part 5 - Additional Notes:</h3>
            <ul>
                <li>
                    No matter what, you need to have your fetch requests and responses throw errors in the cases where the fetch failed.
                    A failed fetch can be caused by numerous things, but what is important to note is that while .catch() is necessary and should always be used,
                    it does not catch server side errors or instances where the fetch did return information but not the right kind, ie the .ok status isn't correct, in this case it is 
                    best to always add a check using an if statement to see if the response from the fetch is not ok, if(!response.ok), and in these instances using the create new Error
                    method to throw an error to the catch statement to prevent any code from executing with the incorrect information from the fetch request.
                </li>
                <li>
                    Also, in instances where you want to add custom properties to say a list item, like a user id that you pulled from a fetch request, html by default does not allow
                    you to define your own properties within the tags, instead, you need to first define that you are doing so using the 'data-' property. Then you can specify the new property you are
                    appending to the tag, like in this case 'data-uid' allows for the user id to be stored or saved to the li tag. 
                </li>
                <li>
                    Under instances where you are pulling data from a database, another server, or even a json file and the object that it returns has multiple properties that you don't care about
                    to simplify the code, you can always use deconstruction, rather than pulling the entire object every time from the specifying the properties you want, by typing ({ prop1, prop2, etc})
                    will save on having to specify the item.prop1, item.prop2, etc for each individual property, mainly useful when you know you are only pulling one or two properties like in the example.
                    This has the benefit of making it easier to code and easier to read for others working on the same project.
                 </li>
            <h3>Takeaway</h3>
            <p>
                This section was mainly about showing the difference between pulling text and json from the fetch request but it was mostly useful in showing good programming practices, like creating a custom property within
                html elements for later use, like an id, and a better way to update the html on a page when pulling data. Rather than appending data one at a time with a for loop and clearing the innerHtml before hand, which
                is how I have mainly been doing it, using something like the .map() method and then the .join() method and creating a long string before setting that equal to the innerHTML is better than doing multiple updates individually.
                This allows for all of the code to format and execute before the user notices any changes, so in cases where the update is slow rather than seeing it slowly update, it will display all at once which can be useful in some cases, or if the item is
                updated multiple times a second it remove any dramatic changes and only shows the whole fetch and not one piece at a time. Also, it highlighted the importance of having error handling beyond just a .catch() method, while that is always required,
                it is best to also include a if statement to check that the fetch itself is not ok even if it returned a response, because a fetch statement can still return a response and claim it was "successful" but the response might not be what the user intended to receive.
            </p> 
        </div>

        <div id="part-6" class="notes">
            <h3>Part 6 - Additional Notes:</h3>
            <ul>
                <li>
                    API stands for application programming interface, a web server somewhere that can provide you with files, and this data will be sent based on which endpoint or url you will use.
                    In order to be allowed to access this data you have to have a key, or a unique identifier to signify you are the one requesting the data. This also allows the server owner to monitor
                    the amount of times you are requesting data or attempting to access data and they can put a limit on the amount of access you have.
                </li>
                <li>
                    You want to keep your api keys a secret, you should use an environment variable when using api keys on your site, this way it is possible for people to have access to the data needed
                    from various websites without them also having access to your personal api keys, while it is accessible through the environment variable, external users do not have access to the value stored
                    in the variable, thus providing a layer of abstraction.
                </li>
                <li>
                    API keys can be stored in multiple places, in the query string, in the header, or even in cookies. Cookies are basically a header as there is a setCookies header that can contain multiple
                    things along with the api keys.
                </li>
                <li>
                    Depending on where the API key is needed, you can either pass it through in the search parameter or query string. Another way is to insert it into the header
                    of your request and this is best done through making a new Header object and using the .append() method on said object, in this case you can use 'x' to specify that
                    you are inserting a custom header, like 'x-api-key', do note that when appending headers certain checks are run in the background to make sure you are not editing static
                    header values that are not intended to change, like where the user is making the request from is unchangeable.
                </li>
                <li>
                    There are certain headers that are forbidden and some names are even forbidden. 
                    <a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name">List Of Forbidden Header Names</a>
                </li>
                <li>
                    Remember, when setting cookies, they only alter the origin where they are created or the domain you are currently on, they are not really meant to be shared. The way to get around this is to modify the request
                    by adding a cache option with default and a credentials option that allows for various options. 
                    'omit' option does not send any authorization headers or tokens that have been set for other places,
                    this is used to prevent accidentally sharing api-keys or authorization tokens between sites since they should always be kept private even from other servers.
                    'same-origin' is the default as it allows the browser to share things if the origin is the same, ie you are attempting to access information on the same page, cookie information would be shared.
                    'include' is basically saying you can send cookies no matter the site, usually the browser does not allow this for security issues as this is basically sending private information to random servers
                    that are not meant to receive them. This provides a huge breach in security as the tokens that are meant to be private are being accepted by random or unknown servers.
                    The way that the browser prevents this is through locking down all fetch request and preventing the browser from sending or receiving any fetch request.
                </li>
                <li>
                    There is a meta tag that you can include in your browser that defines where certain things like src or scripts can come from. Most important is connect-src, this defines where the browser fetch request
                    are allows to fetch from, here you can define a space separated list of where information is allows to be received from.
                </li>
                <li>
                    Example Meta Tag:
                    &lt;meta <br>
                    http-equiv="Content-Security-Policy" <br>
                    content="default-src *; <br>
                      script-src 'self' 'unsafe-inline'; <br>
                      connect-src *;  (This line is signifying that fetch can be made to any server, even ones that the user might not trust so instead of an * it should always be a list of trusted urls)<br>
                      img-src 'self' blob: data: http: https: ; <br>
                    "&gt;
                </li>
            </ul>
            <h3>Takeaway</h3>
            <p>
                In most cases, when accessing data from other servers, it is a requirement to have some sort of api key sent with each request to show said server who is making the request and if they are allowed to pull or push information to the server.
                The use of an API key allows said server to track the amount of information one site has requested and how many times they are requesting it, basically it can be used to limit or track how much information a site attempts to access from the server.
                These key need to be used but they should always be kept hidden or private. To do this it is best to pass it as an environment variable so that the user can access it while not being able to read it or copy it. From here, the api key can be passed in various
                ways when making the request, either through the query parameters in the url of the fetch request or by inserting it into the header of the request object. When using cookies it is always a good idea to limit passing them to other servers or sources and this again can be done 
                via the request object and its credentials options, whether it is set to 'omit', no source other than the one specified has access, 'same-origin', any page that has the same domain as the specified source has access, or 'include' where source has access. Note that the latter should
                never be used as it is a huge security risk for not just the site owner but for its users, and the browser will stop any fetch request if this is set to prevent these security vulnerabilities.
            </p> 
        </div>
    </div>
    
<script src="./app.js" type="module"></script>
</body>
</html>